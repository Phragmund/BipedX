PID是一种广泛运用的闭环控制算法

P表示比例，I表示积分，D表示微分

PID计算公式为：
$$
u(t)=K_p\left[e(t)+ \frac{1}{T_i}\int_0^t e(\tau)d\tau +T_d \frac{de(t)}{dt}\right]
$$
其中u(t)表示t时刻系统应该输出的控制量，e(t)表示t时刻系统存在的偏差（目标值-真实值），Kp表示比例项系数，Kp/Ti表示积分项系数（可简写作Ki），Kp*Td表示微分项系数（可简写作Kd）

当状态不连续时，简化为离散PID

离散PID公式：
$$
u(k)=K_pe(k)+K_i\sum_{n=0}^{k}e(n)+K_d[e(k)-e(k-1)]
$$
k表示离散的时钟刻，u、e、Kp、Ki、Kd定义同上

----

下面以电机转速控制为例介绍PID算法的应用

通过调控电机功率可以调节控制量，控制量的变化值称为调节量；通过霍尔传感器/磁编码器可以获取当前的状态量（真实值）从而获得偏差值

为了让偏差值尽可能快地变为0，在t时刻要输出多大的控制量？

如果让控制量线性变化，未免有些

一个直观的想法是，偏离值越大，调节量就越大，即u与e成线性关系，其比例值为Kp。这样当偏离值很大时，系统就会以较快的速度矫正，且偏离值较小时不会一下子越过目标值（该现象称为超调）。

但是这会产生一个问题，偏离值极小时，调节量也极小，偏差仍然存在且趋于一个稳定值（称为静态误差），导致系统始终达不到目标值

----

为了解决这个问题，我们引入积分项：偏差值对时间的积分值。系统持续运行，每一时刻产生的误差都会积累下来并持续影响/干预着后续的控制量计算公式（错误在不断积累）。这样一来，当系统偏差较小时，这些静态误差会不断积累，使得控制量一点点增大，最终把静态误差完全补偿，偏差值降为0。理想情况下，此时比例项和积分项的调节作用都很小，系统趋于稳定。

当然，这同样会产生一些问题：为了避免超调和抖动（真实值-时间 曲线在目标值附近反复摆动，反复超调的现象称为抖动），我们可能会给比例项一个比较小的值，这样的话在初始阶段偏差值会比较大，而且持续时间较长，此时的偏差值仍然会积累在积分项中，这些初始积累的过大的偏差值会在后续的PID过程中持续发挥作用，这是我们不愿意看到的；同时，消除偏差值的过程肯定是越快越好，积分项需要时间积累才能发挥作用，所以加快偏差值的变化一般需要调大Kp，同样有可能导致变化率过大直接超调。

为了解决上述问题，我们再引入微分项：真实值对时间的导数值（de(t)/dt）。显然导数值反映了真实值的变化率，变化率越大，微分项抑制的抑制作用也就越明显，我们给这两者一个线性关系Kd，就能抑制抖动的产生。当曲线平稳时，微分项几乎为0，不会对稳态造成干扰；当曲线过陡（很快就要超调了）或抖动时，微分项就会产生相应大小的抑制作用，从而使PID算法形成逻辑自洽的闭环。

----

实际调参的过程中也有不少需要注意的事项：

推荐比例：Kp:Ki:Kd=10:1:0.1，但绝对不适用于所有情况！

Kp过大->超调/抖动  Kp过小->响应速度过慢

Ki过大->超调/抖动  Ki过小->静态误差补偿时间过长

Kd过大->响应速度过慢 Kd过小->抑制作用不明显

所以需要反复调整参数

考虑调节电机转速的实际情况，采样过程是不连续的，这对于微分和积分项的计算有一定影响，所以我们要采用离散PID：
$$
u(k)=K_pe(k)+K_i\sum_{n=0}^{k}e(n)+K_d[e(k)-e(k-1)]
$$


积分项简化为每一个离散时刻的偏差值的求和，微分项简化为两个相邻的离散时刻的偏差值之差（也就是偏差值的差分）

具体代码过程也比较简单，伪代码如下：

 ```c
 class PID
 {
 	public double Kp,Ki,Kd,sum,pre;
 	public double control_val(double cur)
 	{
 		double res=0;
 		sum+=cur;
         res+=Kp*cur;
         res+=Ki*sum;
         res+=Kd*(cur-pre);
         pre=cur;
         return res;
 	}
 }
 
 int main()
 {
     ...
     val=获取电机输入值
     控制电机输出值=PID.control_val(val,PID.pre);
     PID.pre=val;
     ...
 }
 ```